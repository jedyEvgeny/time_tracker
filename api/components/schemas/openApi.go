// Package openApi provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.3.0 DO NOT EDIT.
package openApi

import (
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
        "strings"

        "github.com/labstack/echo/v4"
        "github.com/oapi-codegen/runtime"
)

// People defines model for People.
type People struct {
        Address    string  `json:"address"`
        Name       string  `json:"name"`
        Patronymic *string `json:"patronymic,omitempty"`
        Surname    string  `json:"surname"`
}

// GetInfoParams defines parameters for GetInfo.
type GetInfoParams struct {
        PassportSerie  int `form:"passportSerie" json:"passportSerie"`
        PassportNumber int `form:"passportNumber" json:"passportNumber"`
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
        Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
        // The endpoint of the server conforming to this interface, with scheme,
        // https://api.deepmap.com for example. This can contain a path relative
        // to the server, such as https://api.deepmap.com/dev-test, and all the
        // paths in the swagger spec will be appended to the server.
        Server string

        // Doer for performing requests, typically a *http.Client with any
        // customized settings, such as certificate chains.
        Client HttpRequestDoer

        // A list of callbacks for modifying requests which are generated before sending over
        // the network.
        RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
        // create a client with sane default values
        client := Client{
                Server: server,
        }
        // mutate client and add all optional params
        for _, o := range opts {
                if err := o(&client); err != nil {
                        return nil, err
                }
        }
        // ensure the server URL always has a trailing slash
        if !strings.HasSuffix(client.Server, "/") {
                client.Server += "/"
        }
        // create httpClient, if not already present
        if client.Client == nil {
                client.Client = &http.Client{}
        }
        return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
        return func(c *Client) error {
                c.Client = doer
                return nil
        }
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
        return func(c *Client) error {
                c.RequestEditors = append(c.RequestEditors, fn)
                return nil
        }
}

// The interface specification for the client above.
type ClientInterface interface {
        // GetInfo request
        GetInfo(ctx context.Context, params *GetInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetInfo(ctx context.Context, params *GetInfoParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
        req, err := NewGetInfoRequest(c.Server, params)
        if err != nil {
                return nil, err
        }
        req = req.WithContext(ctx)
        if err := c.applyEditors(ctx, req, reqEditors); err != nil {
                return nil, err
        }
        return c.Client.Do(req)
}

// NewGetInfoRequest generates requests for GetInfo
func NewGetInfoRequest(server string, params *GetInfoParams) (*http.Request, error) {
        var err error

        serverURL, err := url.Parse(server)
        if err != nil {
                return nil, err
        }

        operationPath := fmt.Sprintf("/info")
        if operationPath[0] == '/' {
                operationPath = "." + operationPath
        }

        queryURL, err := serverURL.Parse(operationPath)
        if err != nil {
                return nil, err
        }

        if params != nil {
                queryValues := queryURL.Query()

                if queryFrag, err := runtime.StyleParamWithLocation("form", true, "passportSerie", runtime.ParamLocationQuery, params.PassportSerie); err != nil {
                        return nil, err
                } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
                        return nil, err
                } else {
                        for k, v := range parsed {
                                for _, v2 := range v {
                                        queryValues.Add(k, v2)
                                }
                        }
                }

                if queryFrag, err := runtime.StyleParamWithLocation("form", true, "passportNumber", runtime.ParamLocationQuery, params.PassportNumber); err != nil {
                        return nil, err
                } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
                        return nil, err
                } else {
                        for k, v := range parsed {
                                for _, v2 := range v {
                                        queryValues.Add(k, v2)
                                }
                        }
                }

                queryURL.RawQuery = queryValues.Encode()
        }

        req, err := http.NewRequest("GET", queryURL.String(), nil)
        if err != nil {
                return nil, err
        }

        return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
        for _, r := range c.RequestEditors {
                if err := r(ctx, req); err != nil {
                        return err
                }
        }
        for _, r := range additionalEditors {
                if err := r(ctx, req); err != nil {
                        return err
                }
        }
        return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
        ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
        client, err := NewClient(server, opts...)
        if err != nil {
                return nil, err
        }
        return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
        return func(c *Client) error {
                newBaseURL, err := url.Parse(baseURL)
                if err != nil {
                        return err
                }
                c.Server = newBaseURL.String()
                return nil
        }
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
        // GetInfoWithResponse request
        GetInfoWithResponse(ctx context.Context, params *GetInfoParams, reqEditors ...RequestEditorFn) (*GetInfoResponse, error)
}

type GetInfoResponse struct {
        Body         []byte
        HTTPResponse *http.Response
        JSON200      *People
}

// Status returns HTTPResponse.Status
func (r GetInfoResponse) Status() string {
        if r.HTTPResponse != nil {
                return r.HTTPResponse.Status
        }
        return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetInfoResponse) StatusCode() int {
        if r.HTTPResponse != nil {
                return r.HTTPResponse.StatusCode
        }
        return 0
}

// GetInfoWithResponse request returning *GetInfoResponse
func (c *ClientWithResponses) GetInfoWithResponse(ctx context.Context, params *GetInfoParams, reqEditors ...RequestEditorFn) (*GetInfoResponse, error) {
        rsp, err := c.GetInfo(ctx, params, reqEditors...)
        if err != nil {
                return nil, err
        }
        return ParseGetInfoResponse(rsp)
}

// ParseGetInfoResponse parses an HTTP response from a GetInfoWithResponse call
func ParseGetInfoResponse(rsp *http.Response) (*GetInfoResponse, error) {
        bodyBytes, err := io.ReadAll(rsp.Body)
        defer func() { _ = rsp.Body.Close() }()
        if err != nil {
                return nil, err
        }

        response := &GetInfoResponse{
                Body:         bodyBytes,
                HTTPResponse: rsp,
        }

        switch {
        case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
                var dest People
                if err := json.Unmarshal(bodyBytes, &dest); err != nil {
                        return nil, err
                }
                response.JSON200 = &dest

        }

        return response, nil
}

// ServerInterface represents all server handlers.
type ServerInterface interface {

        // (GET /info)
        GetInfo(ctx echo.Context, params GetInfoParams) error
}

// ServerInterfaceWrapper converts echo contexts to parameters.
type ServerInterfaceWrapper struct {
        Handler ServerInterface
}

// GetInfo converts echo context to params.
func (w *ServerInterfaceWrapper) GetInfo(ctx echo.Context) error {
        var err error

        // Parameter object where we will unmarshal all parameters from the context
        var params GetInfoParams
        // ------------- Required query parameter "passportSerie" -------------

        err = runtime.BindQueryParameter("form", true, true, "passportSerie", ctx.QueryParams(), &params.PassportSerie)
        if err != nil {
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter passportSerie: %s", err))
        }

        // ------------- Required query parameter "passportNumber" -------------

        err = runtime.BindQueryParameter("form", true, true, "passportNumber", ctx.QueryParams(), &params.PassportNumber)
        if err != nil {
                return echo.NewHTTPError(http.StatusBadRequest, fmt.Sprintf("Invalid format for parameter passportNumber: %s", err))
        }

        // Invoke the callback with all the unmarshaled arguments
        err = w.Handler.GetInfo(ctx, params)
        return err
}

// This is a simple interface which specifies echo.Route addition functions which
// are present on both echo.Echo and echo.Group, since we want to allow using
// either of them for path registration
type EchoRouter interface {
        CONNECT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        DELETE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        GET(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        HEAD(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        OPTIONS(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PATCH(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        POST(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        PUT(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
        TRACE(path string, h echo.HandlerFunc, m ...echo.MiddlewareFunc) *echo.Route
}

// RegisterHandlers adds each server route to the EchoRouter.
func RegisterHandlers(router EchoRouter, si ServerInterface) {
        RegisterHandlersWithBaseURL(router, si, "")
}

// Registers handlers, and prepends BaseURL to the paths, so that the paths
// can be served under a prefix.
func RegisterHandlersWithBaseURL(router EchoRouter, si ServerInterface, baseURL string) {

        wrapper := ServerInterfaceWrapper{
                Handler: si,
        }

        router.GET(baseURL+"/info", wrapper.GetInfo)

}